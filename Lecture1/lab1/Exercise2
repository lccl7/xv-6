The ROM BIOS
这部分实验，使用QEMU检查32位兼容机的启动过程。
打开两个terminal，都进入到lab目录，然后其中一个输入make qemu-gdb 另一个输入gdb -x .gdbinit
make qemu-gdb
gdb -x .gdbinit
The target architecture is assumed to be i8086
[f000:fff0] 0xffff0:    ljmp   $0xf000,$0xe05b
0x0000fff0 in ?? ()
+ symbol-file obj/kern/kernel
(gdb) 
gdb 执行的第一条指令如下：
[f000:fff0] 0xffff0:    ljmp   $0xf000,$0xe05b， 从此输出可以得出一些结论：
1. IBM PC机开始执行时的物理地址是0x000ffff0，也就是内存为BIOS预留的64KB空间的顶部。
2. PC机开始时候的寄存机为CS = 0xf000, IP = 0xfff0
3. 第一条指令是 jmp , 跳转到CS = 0xf000, IP = 0xe05b
Why ? 因为BIOS在PC“硬连线”到物理地址范围0x000f0000-0x000fffff，这种设计确保
BIOS总是能够在第一次加电或系统重启之后总是能够控制机器 - 这是至关重要的，
因为在加电后内存中没有其他任何指令在可以执行。那么0xf000:0xfff0怎么转换成物理地址的呢？

下面说说实模式取址。
在实模式下，取址按照下面公式执行：
physical address = 16 * segment + offset 
因此，当PC设置CS = 0xf000, IP = 0xfff0时，可得实际的物理地址为：
16 * 0xf000 + 0xfff0      # in hex multiplication by 16 is
   = 0xf0000 + 0xfff0     # easy--just append a 0.
   = 0xffff0
0xffff0恰好是BIOS结束(0x00100000)前的16个字节,因此，毫不意外BIOS第一件要做的事就是执行
jmp 指令跳转到BIOS之前的某个位置。

Exercise 2. Use GDB‘s si (Step Instruction) command to trace into the ROM BIOS 
for a few more instructions, and try to guess what it might be doing. 
You might want to look at Phil Storrs I/O Ports Description, 
as well as other materials on the 6.828 reference materials page.
No need to figure out all the details - 
just the general idea of what the BIOS is doing first.

继续之前的指令：
 1 (gdb) i registers 
 2 eax            0x0    0
 3 ecx            0x0    0
 4 edx            0x663    1635
 5 ebx            0x0    0
 6 esp            0x0    0x0
 7 ebp            0x0    0x0
 8 esi            0x0    0
 9 edi            0x0    0
10 eip            0xfff0    0xfff0
11 eflags         0x2    [ ]
12 cs             0xf000    61440
13 ss             0x0    0
14 ds             0x0    0
15 es             0x0    0
16 fs             0x0    0
17 gs             0x0    0
可以看到CS:IP = 0xf000:0xfff0 即BIOS第一条指令地址为0xf000 * 0x10 + 0xfff0 = 0xffff0

即跳转到0xfe05b. 
如下：
(gdb) si
[f000:e05b]    0xfe05b:    cmpl   $0x0,%cs:0x65a4
0x0000e05b in ?? ()
(gdb) x/10i 0xfe05b (参考qemu-gdb的调试命令)
   0xfe05b:    cmpl   $0x0,%cs:0x65a4
   0xfe062:    jne    0xfd2b9
   0xfe066:    xor    %ax,%ax
   0xfe068:    mov    %ax,%ss
   0xfe06a:    mov    $0x7000,%esp
   0xfe070:    mov    $0xf3c2f,%edx
   0xfe076:    jmp    0xfd12a
   0xfe079:    push   %ebp
   0xfe07b:    push   %edi
   0xfe07d:    push   %esi
